"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodeCrossDomainMessage = exports.encodeCrossDomainMessageV1 = exports.encodeCrossDomainMessageV0 = exports.decodeVersionedNonce = exports.encodeVersionedNonce = exports.big1 = exports.big0 = void 0;
const ethers_1 = require("ethers");
const iface = new ethers_1.ethers.utils.Interface([
    'function relayMessage(address,address,bytes,uint256)',
    'function relayMessage(uint256,address,address,uint256,uint256,bytes)',
]);
const nonceMask = ethers_1.BigNumber.from('0x0000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');
exports.big0 = ethers_1.BigNumber.from(0);
exports.big1 = ethers_1.BigNumber.from(1);
const encodeVersionedNonce = (nonce, version) => {
    return version.or(nonce.shl(240));
};
exports.encodeVersionedNonce = encodeVersionedNonce;
const decodeVersionedNonce = (nonce) => {
    return [nonce.and(nonceMask), nonce.shr(240)];
};
exports.decodeVersionedNonce = decodeVersionedNonce;
const encodeCrossDomainMessageV0 = (target, sender, data, nonce) => {
    return iface.encodeFunctionData('relayMessage(address,address,bytes,uint256)', [target, sender, data, nonce]);
};
exports.encodeCrossDomainMessageV0 = encodeCrossDomainMessageV0;
const encodeCrossDomainMessageV1 = (nonce, sender, target, value, gasLimit, data) => {
    return iface.encodeFunctionData('relayMessage(uint256,address,address,uint256,uint256,bytes)', [nonce, sender, target, value, gasLimit, data]);
};
exports.encodeCrossDomainMessageV1 = encodeCrossDomainMessageV1;
const encodeCrossDomainMessage = (nonce, sender, target, value, gasLimit, data) => {
    const [, version] = (0, exports.decodeVersionedNonce)(nonce);
    if (version.eq(exports.big0)) {
        return (0, exports.encodeCrossDomainMessageV0)(target, sender, data, nonce);
    }
    else if (version.eq(exports.big1)) {
        return (0, exports.encodeCrossDomainMessageV1)(nonce, sender, target, value, gasLimit, data);
    }
    throw new Error(`unknown version ${version.toString()}`);
};
exports.encodeCrossDomainMessage = encodeCrossDomainMessage;
//# sourceMappingURL=encoding.js.map